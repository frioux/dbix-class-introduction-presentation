<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>DBIx::Class (aka DBIC)</title>
<!-- metadata -->
<meta name="contributor" content="youcan[64]netzgesta[46]de" />
<meta name="publisher" content="s5.netzgesta.de" />
<meta name="description" content="S5 1.3 is a very flexible and lightweight slide show system available for anyone to use (including transitions and scalable fonts and images)" />
<meta name="keywords" content="S5, version 1.3, slide show, presentation-mode, projection-mode, powerpoint-like, scala-like, keynote-like, incremental display, scalable fonts, scalable images, transitions, notes, osf, xoxo, css, javascript, xhtml, public domain" />

<meta name="generator" content="S5" />
<meta name="version" content="1" />
<meta name="subject" content="DBIx::Class" />
<meta name="author" content="See first slide" />
<meta name="company" content="N/A" />
<meta name="robots" content="index, follow" />
<meta name="revisit-after" content="7 days" />
<!-- meta additionally -->
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="Content-Style-Type" content="text/css" /><!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- configuration transition extension -->
<meta name="tranSitions" content="true" />
<meta name="fadeDuration" content="500" />
<meta name="incrDuration" content="250" />
<!-- configuration autoplay extension -->
<meta name="autoMatic" content="false" />
<meta name="playLoop" content="true" />
<meta name="playDelay" content="10" />
<!-- configuration audio extension -->
<meta name="audioSupport" content="false" />
<meta name="audioVolume" content="0" />
<meta name="audioError" content="false" />
<!-- configuration audio debug -->
<meta name="audioDebug" content="false" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/scala_utf/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/scala_utf/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/scala_utf/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/scala_utf/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 100%; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 33%; height: 320px; position: relative;}
#anim img {position: absolute; top: 0px; left: 0px;}
.red {color: red;}
.grey {color: gray;}
</style>
<!-- S5 JS -->
<script src="ui/scala_utf/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
   <div id="controls"><!-- DO NOT EDIT --></div>
   <div id="currentSlide"><!-- DO NOT EDIT --></div>
   <div id="header"></div>
   <div id="footer">
      <h1>DBIx::Class Introduction</h1>
      <h2>MTSI 2011-09-08</h2>
   </div>
</div>

<div class="presentation">

   <div class="slide">
      <h1>DBIX::Class (aka DBIC)</h1>
      <h3>for advanced users</h3>
   </div>

   <div class="slide">
      <h1>Contact Info</h1>
      <ul>
         <li>IRC: irc.perl.org #dbix-class</li>
         <li>ML: <a href="http://lists.scsys.co.uk/mailman/listinfo/dbix-class">http://lists.scsys.co.uk/mailman/listinfo/dbix-class</a></li>
         <li><a href="https://metacpan.org/module/DBIx::Class">DBIx::Class</a></li>
      </ul>
   </div>

   <div class="slide">
      <h1>Authors</h1>
      <h4>Originally Leo Lapworth @ LPW 2009</h4>
      <h4>Arthur Axel "fREW" Schmidt</h4>
   </div>

   <div class="slide">
      <h1>Purpose</h1>
      <p>The purpose of this talk is to help you learn or remember the advanced features of DBIx::Class you may have forgotten about.</p>
      <ul class="incremental">
         <li>Note: links in slides are so you can find docs for what I'm talking about later</li>
      </ul>
   </div>

   <div class="slide">
      <h1>DBIC: Create</h1>
<pre>my $book = $book_rs-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#create">create</a>({
   title     =&gt; 'A book title',
   author_id =&gt; $author_id,
});</pre>
      <ul class="incremental">
         <li>No need to pair placeholders and values</li>
         <li>Automatically gets autoincremented id for you</li>
         <li>Transparently uses INSERT ... RETURNING for databases that support it</li>
      </ul>
   </div>

   <div class="slide">
      <h1>DBIC: Read</h1>
<pre>my $book = $book_rs-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#find">find</a>($book_id);

my $book = $book_rs-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#search">search</a>({
   title =&gt; 'A book title',
}, { rows =&gt; 1 })-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#next">next</a>;

my @books = $book_rs-&gt;search({
   author =&gt; $author_id,
})-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#all">all</a>;

while( my $book = $books_rs-&gt;next ) {
 print 'Author of '
    . $book-&gt;title
    . ' is '
    . $book-&gt;author-&gt;name
    . "\n";
}
</pre>
      <ul class="incremental">
         <li>TMTOWTDI</li>
      </ul>
   </div>

   <div class="slide">
      <h1>DBIC: Update</h1>
<pre>$book-&gt;<a href="http://metacpan.org/module/DBIx::Class::Row#update">update</a>({
  title =&gt; 'New title',
});</pre>
      <ul class="incremental">
         <li>Won't update unless value changes</li>
      </ul>
   </div>

   <div class="slide">
      <h1>DBIC: Delete</h1>
<pre>$book-&gt;<a href="http://metacpan.org/module/DBIx::Class::Row#delete">delete</a>;</pre>
   </div>

   <div class="slide">
      <h1>DBIC: Search</h1>
<pre>
my $book = $book_rs-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#search">search</a>({
   'me.name'  =&gt; { -like =&gt; '%monte cristo%' },
   'me.topic' =&gt; 'jailbreak',
})-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#next">next</a>;
</pre>
      <ul class="incremental">
         <li><a href="http://metacpan.org/module/SQL::Abstract">SQL::Abstract</a></li>
         <li>(kinda) introspectible</li>
         <li>Prettier than SQL</li>
      </ul>
   </div>

   <div class="slide">
      <h1>OO Overidability</h1>
      <ul class="incremental">
         <li>Override new if you want to do validation</li>
         <li>Override delete if you want to disable deletion</li>
         <li>and on and on</li>
      </ul>
      <div class="notes">
         <p>I got yelled at about this before by people, so
         we don't get EVERYTHING from OO, but we do get a lot
         so :-P</p>
      </div>
   </div>

   <div class="slide">
      <h1>Convenience Methods</h1>
      <ul class="incremental">
         <li><a href="http://metacpan.org/module/DBIx::Class::ResultSet#find_or_create">find_or_create</a></li>
         <li><a href="http://metacpan.org/module/DBIx::Class::ResultSet#update_or_create">update_or_create</a></li>
      </ul>
   </div>

   <div class="slide">
      <h1>Non-column methods</h1>
      <p>Need a method to get a user's gravatar URL?  Add a
      gravatar_url method to their Result class</p>
   </div>

   <div class="slide">
      <h1>RELATIONSHIPS</h1>
      <ul class="incremental">
         <li><a href="http://metacpan.org/module/DBIx::Class::Relationship#belongs_to">belongs_to</a></li>
         <li><a href="http://metacpan.org/module/DBIx::Class::Relationship#has_many">has_many</a></li>
         <li><a href="http://metacpan.org/module/DBIx::Class::Relationship#might_have">might_have</a></li>
         <li><a href="http://metacpan.org/module/DBIx::Class::Relationship#has_one">has_one</a></li>
         <li><a href="http://metacpan.org/module/DBIx::Class::Relationship#many_to_many">many_to_many</a> (technically not a relationship)</li>
         <li>SET AND FORGET</li>
      </ul>
   </div>

   <div class="slide">
      <h1>EXTENDED RELATIONSHIPS</h1>
      <a href="https://metacpan.org/module/DBIx::Class::Relationship::Base#SYNOPSIS">See here</a>
<pre> __PACKAGE__-&gt;belongs_to(
  output_device =&gt; 'My::Schema::Result::OutputDevice',
  sub {
    my $args = shift;

    my $him = $args-&gt;{foreign_alias};
    my $me  = $args-&gt;{self_alias};
    my $self = $args-&gt;{self_rowobj};
    my $shared = { "$him.shared" =&gt; [qw(Y X)] };
    return ({
      -and =&gt; [
        [
          { "$him.user" =&gt; { -ident =&gt; "$me.user" } },
          $shared,
        ],
        { "$him.phone" =&gt; { -ident =&gt; "$me.phone" } },
      ]
    },
    $self &amp;&amp; {
      -and =&gt; [
        [
          { "$him.user" =&gt; $self-&gt;user },
          $shared,
        ],
        { "$him.phone" =&gt; $self-&gt;phone },
      ]
    });
  },
);</pre>

   </div>

   <div class="slide">
      <h1>-&gt;deploy</h1>
      <p>Perl -&gt; DB</p>
<pre>my $schema = Foo::Schema-&gt;connect(
   $dsn, $user, $pass
);
$schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#deploy">deploy</a>
</pre>
<p>See also: <a href="http://metacpan.org/module/DBIx::Class::DeploymentHandler">DBIx::Class::DeploymentHandler</a></p>
   </div>

   <div class="slide">
      <h1>Schema::Loader</h1>
      <p>DB -&gt; Perl</p>
<pre>package Foo::Schema;
use strict; use warnings;
use base '<a href="http://metacpan.org/module/DBIx::Class::Schema::Loader">DBIx::Class::Schema::Loader</a>';
__PACKAGE__-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema::Loader::Base#CONSTRUCTOR_OPTIONS">loader_options</a>({
   naming =&gt; 'v7',
   debug  =&gt; $ENV{DBIC_TRACE},
});
1;

# elsewhere...

my $schema = Foo::Schema-&gt;connect(
   $dsn, $user, $pass
);
</pre>
   </div>

   <div class="slide">
      <h1>Populate</h1>
      <p>Made for inserting lots of rows very quicky into database</p>
<pre>$schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#populate">populate</a>([ Users =&gt;
   [qw( username password )],
   [qw( frew     &gt;=4char$ )],
   [qw(      ...          )],
   [qw(      ...          )],
);
</pre>
      <ul class="incremental">
         <li>I use this to <a href="http://blog.afoolishmanifesto.com/archives/1255">export our whole (200M~) db to SQLite</a></li>
      </ul>
   </div>

   <div class="slide">
      <h1>Multicreate</h1>
      <p>Create an object and all of it's related objects all at once</p>
<pre>$schema-&gt;resultset('Author')-&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#create">create</a>({
   name =&gt; 'Stephen King',
   books =&gt; [{ title =&gt; 'The Dark Tower' }],
   address =&gt; {
      street =&gt; '123 Turtle Back Lane',
      state  =&gt; { abbreviation =&gt; 'ME' },
      city   =&gt; { name =&gt; 'Lowell'     },
   },
});
</pre>
      <div class="notes">
         <ul>
            <li>books is a has_many</li>
            <li>address is a belongs_to which in turn belongs to state and city each</li>
            <li>for this to work right state and city must mark abbreviation and name as unique</li>
         </ul>
      </div>
   </div>

   <div class="slide">
      <h1>Extensible</h1>
      <p>DBIx::Class helped pioneer fast MI in Perl 5 with Class::C3, so it is made
      to allow extensions to nearly every part of it.</p>
   </div>

   <div class="slide">
      <h1>DBIx::Class Components</h1>
      <h4>NOT ALL ME, LOTS OF AUTHORS</h4>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::TimeStamp">::TimeStamp</a></h1>
      <p>USE THIS for any kind of timestamp (set on create or set on update)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::EncodedColumn">::EncodedColumn</a></h1>
      <p>USE THIS for password columns</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::ResultSet::IgnoreWantarray">::Helper::ResultSet::IgnoreWantarray</a></h1>
      <p>USE THIS for less surprising resultsets (must call -&gt;all)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::OnColumnChange">::Helper::Row::OnColumnChange</a></h1>
      <p>USE THIS to do something when a value changes (per column)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::ResultSet::SetOperations">::Helper::ResultSet::SetOperations</a></h1>
      <p>USE THIS to use UNION and other set ops with DBIC</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::RelationshipDWIM">::Helper::Row::RelationshipDWIM</a></h1>
      <p>USE THIS to avoid carpel tunnel (has_many cars =&gt; 'Cars', ...)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::StorageValues">::Helper::Row::StorageValues</a></h1>
      <p>USE THIS to keep track of what's in the DB before you call update and after you use an accessor</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::SubClass">::Helper::Row::SubClass</a></h1>
      <p>USE THIS to subclass parts of your schema (deprecated by new versions of Class::C3::Componentised)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::ToJSON">::Helper::Row::ToJSON</a></h1>
      <p>USE THIS to generate a sensible TO_JSON method</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Candy">::Candy</a></h1>
      <p>Use this to avoid carpel tunnel (no more __PACKAGE__)</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::ResultSet::ResultClassDWIM">::Helper::ResultSet::ResultClassDWIM</a></h1>
      <p>Use this to avoid carpel tunnel ( result_class =&gt; '::HRI' )</p>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::ResultSet::RemoveColumns">::Helper::ResultSet::RemoveColumns</a></h1>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::ResultSet::Random">::Helper::ResultSet::Random</a></h1>
   </div>

   <div class="slide">
      <h1><a href="http://beta.metacpan.org/module/DBIx::Class::Helper::Row::JoinTable">::Helper::Row::JoinTable</a></h1>
   </div>

   <div class="slide">
      <h1>Extensible: Kioku</h1>
      <ul class="incremental">
         <li><a href="http://metacpan.org/module/DBIx::Class::Schema::KiokuDB">DBIx::Class::Schema::KiokuDB</a></li>
         <li>Kioku is the new hotness</li>
         <li>Mix RDBMS with Object DB</li>
         <li>beta ( == sexy )</li>
      </ul>
   </div>

   <div class="slide">
      <h1>Result vs ResultSet</h1>
         <ul class="incremental">
            <li>Result == Row</li>
            <li>ResultSet == Query Plan<ul class="incremental">
               <li>Internal Join Optimizer for all DB's (!!!)</li>
            </ul></li>
            <li>(less important but...)</li>
            <li>ResultSource == Table</li>
            <li>Storage == Database</li>
         </ul>
   </div>

   <div class="slide">
      <h1><a href="http://metacpan.org/module/DBIx::Class::Manual::Cookbook#Predefined_searches">ResultSet methods</a></h1>
<pre>package MyApp::Schema::ResultSet::Book;
use base 'DBIx::Class::ResultSet';
sub good {
   my $self = shift;
   $self-&gt;search({
      $self-&gt;current_source_alias .
         '.rating' =&gt; { '&gt;=' =&gt; 4 },
   })
};
sub cheap {
   my $self = shift;
   $self-&gt;search({
      $self-&gt;current_source_alias .
         '.price' =&gt; { '&lt;=' =&gt; 5}
   })
};
# ...
1;
      </pre>
   </div>

   <div class="slide">
      <h1>ResultSet method notes</h1>
      <ul class="incremental">
         <li>All searches should be ResultSet methods</li>
         <li>Name has obvious meaning</li>
         <li><a href="http://metacpan.org/module/DBIx::Class::ResultSet#current_source_alias">current_source_alias</a> helps things to work no matter what</li>
      </ul>
   </div>

   <div class="slide">
      <h1>ResultSet method in Action</h1>
      <pre>$schema-&gt;resultset('Book')-&gt;good</pre>
   </div>

   <div class="slide">
      <h1>ResultSet Chaining</h1>
<pre>$schema-&gt;resultset('Book')
   -&gt;good
   -&gt;cheap
   -&gt;recent
</pre>
   </div>

   <div class="slide">
      <h1>search_related</h1>
<pre>my $score = $schema-&gt;resultset('User')
   -&gt;search({'me.userid' =&gt; 'frew'})
   -&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#related_resultset">related_resultset</a>('access')
   -&gt;related_resultset('mgmt')
   -&gt;related_resultset('orders')
   -&gt;telephone
   -&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#search_related">search_related</a>( shops =&gt; {
      'shops.datecompleted' =&gt; {
         -between =&gt; ['2009-10-01','2009-10-08']
      }
   })-&gt;completed
   -&gt;related_resultset('rpt_score')
   -&gt;<a href="http://metacpan.org/module/DBIx::Class::ResultSet#get_column">get_column</a>('raw_scores')
   -&gt;first;
</pre>
   </div>

   <div class="slide">
      <h1>bonus rel methods</h1>
<pre>my $book = $author-&gt;<a href="http://metacpan.org/module/DBIx::Class::Relationship::Base#create_related">create_related</a>(
   <strong>books</strong> =&gt; {
      title =&gt; 'Another Discworld book',
   }
);

my $book2 = $pratchett-&gt;<a href="http://metacpan.org/module/DBIx::Class::Relationship::Base#add_to_$rel">add_to_<strong>books</strong></a>({
   title =&gt; 'MOAR Discworld book',
});</pre>
      <ul class="incremental">
         <li>Automaticaly fills in foreign key for you</li>
      </ul>
   </div>

   <div class="slide">
      <h1>Excellent Transaction Support</h1>
<pre>$schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#txn_do">txn_do</a>(sub {
   ...
});

my $guard = $schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#txn_scope_guard">txn_scope_guard</a>;
# ...
$guard-&gt;commit;

$schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#txn_begin">txn_begin</a>; # &lt;-- low level
# ...
$schema-&gt;<a href="http://metacpan.org/module/DBIx::Class::Schema#txn_commit">txn_commit</a>;
</pre>
   </div>

   <div class="slide">
      <h1>InflateColumn</h1>
<pre>package Foo::Schema::Result::Book;
use base 'DBIx::Class::Core';
use DateTime::Format::MySQL;
# Result code here
__PACKAGE__-&gt;load_components('<a href="http://metacpan.org/module/DBIx::Class::InflateColumn">InflateColumn</a>');
__PACKAGE__-&gt;<strong><a href="http://metacpan.org/module/DBIx::Class::InflateColumn#inflate_column">inflate_column</a></strong>(
   <strong>date_published</strong> =&gt; {
      inflate =&gt; sub {
         DateTime::Format::MySQL-&gt;parse_date(
            shift
         )
      },
      deflate =&gt; sub { shift-&gt;ymd },
   },
);
# Automatic see: DBIC::InflateColumn::DateTime</pre>
   </div>

   <div class="slide">
      <h1>InflateColumn: deflation</h1>
<pre>$book-&gt;date_published(DateTime-&gt;now);
$book-&gt;update;</pre>
   </div>

   <div class="slide">
      <h1>InflateColumn: inflation</h1>
<pre>say $book-&gt;date_published-&gt;month_abbr;</pre>

<strong><em>Nov</em></strong>
   </div>

   <div class="slide">
      <h1>FilterColumn</h1>
<pre>package Foo::Schema::Result::Book;
use base 'DBIx::Class::Core';
# Result code here
__PACKAGE__-&gt;load_components('<a href="http://metacpan.org/module/DBIx::Class::FilterColumn">FilterColumn</a>');

__PACKAGE__-&gt;<strong><a href="http://metacpan.org/module/DBIx::Class::FilterColumn#filter_column">filter_column</a></strong>(
   <strong>length</strong> =&gt; {
      to_storage   =&gt; 'to_metric',
      from_storage =&gt; 'to_imperial',
   },
);

sub to_metric   { $_[1] * .305 }
sub to_imperial { $_[1] * 3.28 }
   </div>

   <div class="slide">
      <h1><a href="http://metacpan.org/module/DBIx::Class::ResultSetColumn">ResultSetColumn</a></h1>
<pre>my $rsc = $schema-&gt;resultset('Book')
   -&gt;get_column('price');
$rsc-&gt;first;
$rsc-&gt;all;
$rsc-&gt;min;
$rsc-&gt;max;
$rsc-&gt;sum;
</pre>
   </div>

   <div class="slide">
      <h1>Aggregates</h1>
<pre>my @res = $rs-&gt;search({}, {
   <a href="http://metacpan.org/module/DBIx::Class::ResultSet#select">select</a>   =&gt; [
      'price',
      'genre',
      { max =&gt; price },
      { avg =&gt; price },
   ],
   <a href="http://metacpan.org/module/DBIx::Class::ResultSet#as">as</a>       =&gt; [
      qw(price genre max_price avg_price)
   ],
   <a href="http://metacpan.org/module/DBIx::Class::ResultSet#group_by">group_by</a> =&gt; [qw(price genre)],
});
for (@res) {
   say $_-&gt;price . ' ' . $_-&gt;genre;
   say $_-&gt;get_column('max_price');
   say $_-&gt;get_column('min_price');
}</pre>
   </div>

   <div class="slide">
      <h1>Aggregates Notes</h1>
      <ul class="incremental">
         <li>Careful, get_column can basicaly mean THREE things</li>
         <li>private for get what you should use an accessor for</li>
         <li>public for what there is no accessor for</li>
         <li>public for get resultset column (prev slide)</li>
      </ul>
   </div>

   <div class="slide">
      <h1>HRI</h1>
<pre>$rs-&gt;search({}, {
  <a href="http://metacpan.org/module/DBIx::Class::ResultSet#result_class">result_class</a> =&gt;
    '<a href="http://metacpan.org/module/DBIx::Class::ResultClass::HashRefInflator">DBIx::Class::ResultClass::HashRefInflator</a>',
});</pre>
      <ul class="incremental">
         <li>Easy on memory</li>
         <li>Mega fast</li>
         <li>Great for quick debugging</li>
         <li>Great for performance tuning (we went from 2m to &lt; 3s)</li>
      </ul>
   </div>

   <div class="slide">
      <h1><a href="http://metacpan.org/module/DBIx::Class::Manual::Cookbook#Subqueries">Subquery</a> Support</h1>
<pre>my $inside_query = $schema-&gt;resultset('Artist')
   -&gt;search({
    name =&gt; [ 'Billy Joel', 'Brittany Spears' ],
})-&gt;get_column('id')-&gt;as_query;

my $rs = $schema-&gt;resultset('CD')-&gt;search({
    artist_id =&gt; { -in =&gt; $inside_query },
});</pre>
   </div>

   <div class="slide">
      <h1><a href="http://metacpan.org/module/SQL::Abstract#Literal_SQL_with_placeholders_and_bind_values_(subqueries)">Bare SQL w/ Placeholders</a></h1>
<pre>$rs-&gt;update({
   # !!! SQL INJECTION VECTOR
   price =&gt; \"price + $inc",
});

$rs-&gt;update({
   price =&gt; \['price + ?', [inc =&gt; $inc]],
});
</pre>
   </div>

   <div class="slide">
      <h1>DBIx::Class</h1>
<li>  Brainchild of mst</li>
<li>  Inspired by Class::DBI / Class::DBI::Sweet</li>
<li>  Inherited large portion of API (and warts)</li>
<li>  Widely popular</li>
<li>  Just as widely misunderstood</li>
   </div>

   <div class="slide">
      <h1>Misconceptions: What is DBIx::Class</h1><ul>
<li>  A DBI extension? </li>
<li>  ORM? </li>
<li>  Framework? </li>
   </div>

   <div class="slide">
      <h1>Misconceptions: What is DBIx::Class</h1><ul>
<li>  A DBI extension? </li>
<li>  ORM? </li>
<li>  Framework? </li>
<li>  NONE OF THE ABOVE (but a bit of each) </li>
   </div>

<div class="slide">
      <h1>Flexible RDBMS de-hater</h1><ul>
<li>Designed to work with flat-row based resultsets </li>
<li>Currently <i>somewhat</i> rooted in SQL/DBI (lack of alternative use-cases) </li>
<li>Individual layers are mostly independent (reports to the contrary welcome) </li>
</div>

<div class="slide">
      <h1>Loosely coupled abstractions</h1><ul>
<li>  Query definition/manipulation framework (DBIx::Class::ResultSet) </li>
<li>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI )) </li>
<li>  Data-Source/Relationship Model abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource) </li>
<li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator) </li>
</div>


   <div class="slide">
      <h1>Random example - SQL metaprogramming</h1>
    <pre style="font-size:80%">
    $shadow_rs->search({ shadow_val_title => 'stab' })->insert({

      shadow_stage => 2,

      shadow_timestamp => 666,

      shadowed_lifecycle => \"(
        SELECT COALESCE( MAX( shadowed_lifecycle ), 0 ) + 1 FROM $shadow_table
      )",

      rel_shadow_artists_lifecycle =>
        $shadowed_cd->search_related('artist')
                     ->search_related('shadows', {}, { rows => 1 })
                      ->get_column('shadowed_lifecycle')
                       ->as_query
      ,
    });</pre>
   </div>


   <div class="slide">
      <pre style="font-size:60%">
INSERT
  INTO shadow_cds (
    shadow_stage,
    shadow_timestamp,
    shadow_val_title,
    shadow_lifecycle,
    rel_shadw_artists_lifecycle
  ) VALUE (
    '2',
    '666',
    'stab',
    '2',
    (
      SELECT COALESCE( MAX( shadowed_lifecycle ), 0 ) + 1
        FROM shadow_cds
    ),
    (
      SELECT shadows.shadowed_lifecycle
        FROM artists me
        JOIN shadow_artists shadows
          ON shadows.shadowed_curpk_name = me.name
      WHERE me.name = 'gaga'
      LIMIT '1'
    ),
  )

     </div><div class="slide">
      <h1>Confusing design</h1><ul>
<li>Awkwardness is justified </li>
<li>Gradually removed where it isn't (reports to the contrary welcome) </li>
<li>Can be mostly ignored
</dev>

     </div><div class="slide">
      <h1>Confusing design: Components</h1><ul>
<li>  Roles in 2005
<li>  <pre>__PACKAGE__->load_components == multiple with statements</pre>
<li>Writing a component is no different than writing a role
<li>Using real Moose roles just works like it does everywhere else (courtesy of MooseX::NonMoose)
<li>Multiple inheritance is not evil when you know what you are doing (and we do)
</div>

     <div class="slide">
      <h1>Confusing design: Result Class / Core Components</h1><ul>
<p><pre style="font-size:50%">
use base 'DBIx::Class';
__PACKAGE__->load_components('Core');

   === (almost)

use base 'DBIx::Class::Core';
</div>

     <div class="slide">
      <h1>Confusing design: Result Class / Core Components</h1><ul>
<p><pre style="font-size:50%">
use base 'DBIx::Class';
__PACKAGE__->load_components('Core');

   === (almost)

use base 'DBIx::Class::Core';

   ===

use base qw(
  DBIx::Class::Relationship
  DBIx::Class::Relationship::Helpers
  DBIx::Class::Relationship::HasMany
  DBIx::Class::Relationship::HasOne
  DBIx::Class::Relationship::BelongsTo
  DBIx::Class::Relationship::ManyToMany
  DBIx::Class::Relationship::Accessor
  DBIx::Class::Relationship::CascadeActions
  DBIx::Class::Relationship::ProxyMethods
  DBIx::Class::Relationship::Base
  DBIx::Class::InflateColumn
  DBIx::Class::PK::Auto
  DBIx::Class::PK
  DBIx::Class::Row
  DBIx::Class::ResultSourceProxy::Table
  DBIx::Class::ResultSourceProxy
  DBIx::Class
  DBIx::Class::Componentised
  Class::C3::Componentised
  DBIx::Class::AccessorGroup
  Class::Accessor::Grouped
)

</div>


     <div class="slide">
      <h1>Confusing design: Result Source instances</h1><ul>
<li>CDBI legacy, turned out to be extremely useful
<li>Proxying<p>
    <pre>
__PACKAGE__->add_column('name')
      ===
__PACKAGE__->result_source_instance->add_column('name')
</pre>
<li>JS-like prototypical OO with partial implicit cloning<p>
<pre>
My::Schema::Result::Artist->has_many(...) (i.e. __PACKAGE__->has_many)
  !=
My::Schema->source('Artist')->has_many(...)
  !=
$schema->source('Artist')->has_many(...)
</pre>
</div>

     <div class="slide">
      <h1>Confusing design: Class data / Class::Accessor::Grouped</h1><ul>
<li>The pre-moose way of doing sane attributes
<li>First sane implementation of hybrid class/instance data
<li>Gradual internals migration to Moo where it makes sense
</ul><pre style="font-size:60%">

__PACKAGE__->mk_group_accessor(simple_lazy_required => qw( food beer ));

sub get_simple_lazy_required {
  if (defined (my $v = $_[0]->get_simple($_[1]) ) ) {
    return $v;
  }
  $_[0]->throw_exception("You must set '$_[1]' before accessing it");
}

sub set_simple_lazy_required {
  shift->set_simple(@_);
}
</pre>


     </div><div class="slide">
      <h1>Confusing design: Class data / Class::Accessor::Grouped</h1>
 <p>
 <pre>
    __PACKAGE__->add_column('foo')

among other things does

    __PACKAGE__->mk_group_accessor(column => 'foo');
</pre>

     </div><div class="slide">
      <h1>Confusing design: Class data / Class::Accessor::Grouped</h1>
 <p>
 <pre>
    __PACKAGE__->add_column('foo')

among other things does

    __PACKAGE__->mk_group_accessor(column => 'foo');
</pre>
<p>Ever heard of get_column() ?

   </div>


<div class="slide">
      <h1>Loosely coupled abstractions</h1><ul>
<li>  Query definition/manipulation framework (DBIx::Class::ResultSet)
<li>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))
<li>  Data-Source/Relationship Model abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource)
<li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator / &lt;your own class&gt;)
</div>

<div class="slide">
      <h1>Loosely coupled abstractions</h1>

<p><pre style="font-size:70%">
  my $schema_instance               # knows about its registered sources (load_namespaces,
    = Schema::Class->connect(...);  # load_classes, compose_namespace, etc), and about its
                                    # storage instance (the storage IO abstraction)

  my $result_source_instance
    = $schema_instance->source('Artist') # knows how to refer to the actual data source
                                         # when talking to storage, knows the source
                                         # metadata, knows the default result inflation class

  my $resultset_instance            # query plan, holds a reference to the source and infers
    = $result_sources_instance;     # from it the storage-source name, and the default selection
( or $schema->resultset('Artist')   # and/or restrictions from source instance metadata
                                    # ALL OVERRIDABLE

  my $row_object
    = $resultset_instance->next     # actual query execution, raw result is processed and returned
                                    # according to the $resultset_instance settings
                                    # CAN BE ANYTHING
</pre>
</div>

   </div><div class="slide">      <h1>Loosely coupled abstractions</h1>
<h2>Query definition/manipulation framework (DBIx::Class::ResultSet)</h2><ul>
<li>  Query plan (geared to a specific source)
<li> Easily subclassable (load_namespaces - just name accordingly)
<li>  Immutable
<li>  Able to express/override all query primitives
<li>  Holds returned selection <i>parsing</i> metadata:
<pre>
    result_class
    inflation-specification (as)
</pre>
<li> Inherits defaults from referenced Result Source (if any)
<li><b>EVERYTHING IS OVERRIDABLE</b>

   </div><div class="slide">      <h1>Loosely coupled abstractions</h1>
<h2>Query definition language - not hardcoded (almost)</h2><ul>
<li>SQL::Abstract current way of doing things
<li>Trivial raw SQL passthrough:
<pre>
  $schema->resultset('Artist')->search(
    \[
      'any sql you want here ? with ? bindvals',
      [ {}, 'bind_val_1' ],
      [ {}, 'bind_val_2' ],
    ]
  )
</pre>
<li>Can be changed to something else your current storage understands
<li>Full migration to Data::Query by end of 2011
</div>

<div class="slide">
      <h1>ResultSet Chains are Infinitely nestable</h1><ul>

<li>    Shallow nesting (chaining)
<pre>
    $rs->search({ name => { '!=', 'blah' }})
        ->search({ name => { '!=', undef }})

    ... WHERE name != 'blah' AND name IS NOT null
</pre>
<li>    Subquery nesting
<pre style="font-size:80%">
    $rs->search({}, { distinct => 1 })
        ->as_subselect_rs
         ->search({}, { rows => 1 })

    ... SELECT FROM (SELECT * FROM artist GROUP_BY * ) LIMIT 1
</pre>
   </div><div class="slide">
      <h1>Relationship metadata traversal</h1><ul>
<pre>
    $artist_rs->search_related('cds')
               ->search_related('artwork')
                ->search_related('artwork_to_artists')
                 ->search_related('artist')

  FROM artist me
    JOIN cd cds
      ON cds.artist = me.artistid
    JOIN cd_artwork artwork
      ON artwork.cd_id = cds.cdid
    JOIN artwork_to_artist artwork_to_artist
      ON artwork_to_artist.artwork_cd_id = artwork.cd_id
    JOIN artist artist
      ON artist.artistid = artwork_to_artist.artist_id
</pre>
<li> Trivial to hide behind a ResultSet method:
<pre> $artist_rs->my_cd_artwork_creators</pre>



   </div><div class="slide">
      <h1>Overridable/augmentable default selection</h1><ul>
<pre style="font-size:65%">
  $rs->search({}, { '+columns' => ['foo', { max_bar => \'MAX(bar)' }] });
  $rs->search({}, { select => 'multi_value_func', as => [qw(val1 val2)] });
</pre>
<li> Currently does not create accessors on the fly, planned feature

   </div><div class="slide">
      <h1 style="font-size:80%">Overridable/augmentable default selection: AS IS NOT AS</h1><ul>
<li>Represents an inflation plan
<pre style="font-size:65%">
  $artist_rs->search({}, { prefetch => { cds => 'tracks' } });

    ===

  $artist_rs->search({}, {
    join  => { cds => 'tracks' },

    '+columns' => {
      'cds.title'         => 'cds.title',
      'cds.year'          => 'cds.year',
      'cds.tracks.title'  => 'tracks.title',
      'cds.tracks.pos'    => 'tracks.pos',
    },

    &lt;some collapser magic that I can not yet sanely expose>
    (in the works, promise!)
  });
</pre>

<li>A source of limitless confusion
<li>columns/+columns design unfortunate



   </div><div class="slide">
      <h1>ResultSet operations (CRUD)</h1><ul style="font-size:90%">
<li>  No-result CREATE/UPDATE/RETRIEVE
<pre>
    $rs->populate
    $rs->update
    $rs->delete
</pre>
<li>  Low level RETRIEVE ($sth->selectall_arrayref/fetchrow_array)<br>
    (epecially when you want to limit DBIC to a super-smart SQL generator)
<pre>
    $rs->cursor->next/all
</pre>
<li>  Roundtrip Result-inflating CREATE/RETRIEVE
<pre>
    $rs->create
    $rs->next/all
</pre>

<li>  Inflation (what happens on ->next/->all)
<pre>
    $rs->result_class->inflate_result(
      $rs->cursor->next
    + as-specification from $rs
    )
</pre>

   </div>



<div class="slide">
      <h1>Loosely coupled abstractions</h1><ul>
<li>  Query definition/manipulation framework (DBIx::Class::ResultSet)
<li>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))
<li>  Data-Source/Relationship Model abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource)
<li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator / &lt;your own class&gt;)
</div>




<div class="slide">
      <h1>Storage Layer</h1>
<h2>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))</h2><ul>
<li>    Holds $dbh (almost like DBIx::Connector)
<li>    Fork/thread and stale connection handling
<li>    Transaction/savepoint handling
<li>    Invokes correct DBIx::Class::Storage::SQLMaker subclass (sql dialects)
<li>    Buggy DBD workarounds (over 8000 loc)
<li>    Could be shared between multiple $schema's
<li>    Much more on the abstraction front
<li>    Plans to put it standalone on CPAN in early 2012

</div>


<div class="slide">
      <h1>Storage Layer</h1>
<h2>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))</h2><ul>
<li>Provides -&gt;dbh_do - NOTHING WRONG WITH USING IT<br>
<pre>
  $schema->storage->dbh_do(sub {
    return $_[1]->selectall_arrayref(
      &lt;something unholy goes here>
    )
  });
</pre>
<li>Although $schema-&gt;txn_do is better
</div>

<div class="slide">
      <h1>Loosely coupled abstractions</h1><ul>
<li>  Query definition/manipulation framework (DBIx::Class::ResultSet)
<li>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))
<li>  Data-Source/Relationship Model abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource)
<li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator)
</div>

   </div><div class="slide">
      <h1>Schema</h1><ul>
<li>  Bundles multiple ResultSources accessible over the same Storage instance
<li>  Circular "where is my towel day"
<li> Every ResultSource instance knows about its Schema and every Schema instance knows about its registered Sources

</div>

<div class="slide">
      <h1>ResultSource</h1><ul>
  <li>Standalone source metadata

   </div><div class="slide">
      <h1>Source name (->table)</h1><ul>
<li>  (table/view/procedure/etc)
<li>  Direct SQL expression

   </div><div class="slide">
      <h1>Columns (->add_columns)</h1><ul>
<li>  Expected result definition
<li>  Non-mandatory(!) selection defaults
<li>  Accessor autogeneration
<li>  Optional metadata (data_type, pre/postprocessing)

   </div><div class="slide">
      <h1>Constraint Hints</h1>
      <h2>(->set_primary_columns / ->add_unique_constraint )</h2><ul>
<li>  Also optional
<li>  Good idea - see DBIx::Class::Manual::Intro::The_Significance_and_Importance_of_Primary_Keys

   </div><div class="slide">
      <h1>Relationships</h1>
      <h2>( belongs_to / has_many / has_one / might_have ... )</h2><ul>
<li>  Between standalone sources
<li>  One way
<li>  Express single JOIN

   </div><div class="slide">
      <h1>Relationship types</h1><ul>
<li>  Arguably the worst CDBI legacy
<pre>
  belongs_to -
    "I have a (partially) dedicated column to hold
     value(s) of *ANOTHER* Source's column(s)"

  everything else -
    "The other Source has a (partially) dedicated
     column to hold the value(s) of *MY* column(s)"
</pre>
   </div>


<div class="slide">
      <h1>Loosely coupled abstractions</h1><ul>
<li>  Query definition/manipulation framework (DBIx::Class::ResultSet)
<li>  Storage I/O abstraction layer (DBIx::Class::Storage(::DBI ))
<li>  Data-Source/Relationship Model abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource)
<li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator)
</div>

<!--
   <div class="slide">
      <h1>SQL</h1><ul>
  NOT Turing-Complete
  Infinitely nestable
  Limited amount of primitives

SQL Statement Anatomy

   <div class="slide">
      <h1>SQL anatomy in evaluation order

  Source
    FROM artist

  Semantic restriction
    FROM artist WHERE name = 'queen'

  Aggregation
    FROM artist WHERE name = 'queen' GROUP BY first_name, last_name

  Size restriction
    FROM artist WHERE name = 'queen' GROUP BY first_name, last_name LIMIT 5

  Selection
    SELECT first_name, last_name FROM artist WHERE name = 'queen' GROUP BY first_name, last_name LIMIT 5

  Not really SQL specific(!)
-->

   </div><div class="slide">
      <h1>DBIx::Class::Core / DBIx::Class::Row</h1><ul>
<li>  Data accessors
<li>  Relationship Accessors
<li>  Hooks to ResultSource/Schema/ResultSet instances
<li>  Handy corresponding row manipulation methods
<li>  Plugins (components/roles/whateveryouwannacallit)

   </div><div class="slide">
      <h1>DBIx::Class::ResultClass::HashRefInflator</h1><ul>
<li>  Plain hashes
<li>  Respecting nesting of "as"-specification

   </div><div class="slide">
      <h1>Write your own result class</h1><ul>
<li>  DBIC layers have *NO EXPECTATIONS* of result format

   </div><div class="slide">
      <h1>So what good is all of this?</h1><ul style="font-size:90%">

      <li>  Data-Source/Relationship abstraction framework (DBIx::Class::Schema/DBIx::Class::ResultSource)
<ul>
<li>    Templated generation of source definitions
<li>    Subsequent deploy()
</ul>

      <li>  Query definition/manipulation framework (DBIx::Class::ResultSet)
<ul>
<li>    Override query primitives
<li>    Use your own SQL definition language
<li>    Use a language to work with non-SQL storages
</ul>

      <li>  Storage I/O abstraction layer (DBIx::Class::Storage (::DBI )
<ul>
<li>    Reduced headaches when switching databases
<li>    Reduced (but not eliminated) cursing of DBD authors
</ul>
      <li>  Retrieved result parser (DBIx::Class::Row / DBIx::Class::ResultClass::HashRefInflator)
<ul>
<li>    ANYTHING YOU CAN POSSIBLY IMAGINE
</ul>
   </div>

</div>
   <div class="slide">
      <h1>Questions?</h1>
   </div>

   <div class="slide">
      <h1>END</h1>
   </div>
</div>
</body>
</html>
